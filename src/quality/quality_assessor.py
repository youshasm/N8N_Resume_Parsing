# Generated by Copilot
import cv2
import numpy as np
from PIL import Image, ImageEnhance, ImageFilter
import math
from typing import Tuple, Dict, Any
from dataclasses import dataclass

from ..models.document import QualityMetrics, Document
from ..utils.config import Config
from ..utils.logger import Logger

class QualityAssessor:
    """Assess document quality for intelligent routing"""
    
    def __init__(self):
        self.logger = Logger(__name__)
        self.config = Config()
    
    def assess_quality(self, image_path: str) -> QualityMetrics:
        """
        Comprehensive quality assessment of document image
        Returns QualityMetrics with scores 0-100
        """
        try:
            # Load image
            img_cv = cv2.imread(image_path)
            img_pil = Image.open(image_path)
            
            if img_cv is None:
                raise ValueError(f"Could not load image: {image_path}")
            
            # Convert to grayscale for analysis
            gray = cv2.cvtColor(img_cv, cv2.COLOR_BGR2GRAY)
            
            # Assess different quality aspects
            blur_score = self._assess_blur(gray)
            contrast_score = self._assess_contrast(gray)
            resolution_score = self._assess_resolution(img_cv)
            text_clarity_score = self._assess_text_clarity(gray)
            brightness_score = self._assess_brightness(gray)
            skew_angle = self._detect_skew(gray)
            noise_level = self._assess_noise(gray)
            
            # Calculate overall score with weighted average
            weights = {
                'blur': 0.25,
                'contrast': 0.20,
                'resolution': 0.15,
                'text_clarity': 0.25,
                'brightness': 0.10,
                'skew': 0.05
            }
            
            # Skew penalty (0 degrees = no penalty, >5 degrees = significant penalty)
            skew_penalty = max(0, min(30, abs(skew_angle) * 6))
            
            overall_score = (
                blur_score * weights['blur'] +
                contrast_score * weights['contrast'] +
                resolution_score * weights['resolution'] +
                text_clarity_score * weights['text_clarity'] +
                brightness_score * weights['brightness'] -
                skew_penalty
            )
            
            overall_score = max(0, min(100, overall_score))
            
            metrics = QualityMetrics(
                overall_score=round(overall_score, 2),
                blur_score=round(blur_score, 2),
                contrast_score=round(contrast_score, 2),
                resolution_score=round(resolution_score, 2),
                text_clarity_score=round(text_clarity_score, 2),
                brightness_score=round(brightness_score, 2),
                skew_angle=round(skew_angle, 2),
                noise_level=round(noise_level, 2)
            )
            
            self.logger.debug(f"Quality assessment completed for {image_path}", {
                'overall_score': overall_score,
                'blur_score': blur_score,
                'contrast_score': contrast_score,
                'skew_angle': skew_angle
            })
            
            return metrics
            
        except Exception as e:
            self.logger.error(f"Error assessing image quality: {e}")
            # Return default low quality metrics on error
            return QualityMetrics(
                overall_score=25.0,
                blur_score=25.0,
                contrast_score=25.0,
                resolution_score=25.0,
                text_clarity_score=25.0,
                brightness_score=50.0,
                skew_angle=0.0,
                noise_level=50.0
            )
    
    def _assess_blur(self, gray_image: np.ndarray) -> float:
        """Assess image blur using Laplacian variance"""
        try:
            # Calculate Laplacian variance
            laplacian_var = cv2.Laplacian(gray_image, cv2.CV_64F).var()
            
            # Convert to 0-100 scale (higher = less blurry)
            # Typical values: <100 = very blurry, >500 = sharp
            blur_score = min(100, (laplacian_var / 500) * 100)
            
            return max(0, blur_score)
            
        except Exception as e:
            self.logger.warning(f"Error assessing blur: {e}")
            return 50.0
    
    def _assess_contrast(self, gray_image: np.ndarray) -> float:
        """Assess image contrast using standard deviation"""
        try:
            # Calculate standard deviation of pixel intensities
            std_dev = np.std(gray_image)
            
            # Convert to 0-100 scale
            # Typical values: <30 = low contrast, >80 = high contrast
            contrast_score = min(100, (std_dev / 80) * 100)
            
            return max(0, contrast_score)
            
        except Exception as e:
            self.logger.warning(f"Error assessing contrast: {e}")
            return 50.0
    
    def _assess_resolution(self, image: np.ndarray) -> float:
        """Assess image resolution"""
        try:
            height, width = image.shape[:2]
            total_pixels = height * width
            
            # Resolution scoring
            if total_pixels >= 2000000:  # ~1600x1250 or higher
                return 100.0
            elif total_pixels >= 1000000:  # ~1000x1000
                return 80.0
            elif total_pixels >= 500000:   # ~700x700
                return 60.0
            elif total_pixels >= 200000:   # ~450x450
                return 40.0
            else:
                return 20.0
                
        except Exception as e:
            self.logger.warning(f"Error assessing resolution: {e}")
            return 50.0
    
    def _assess_text_clarity(self, gray_image: np.ndarray) -> float:
        """Assess text clarity using edge detection"""
        try:
            # Apply Canny edge detection
            edges = cv2.Canny(gray_image, 50, 150)
            
            # Calculate edge density
            edge_density = np.sum(edges > 0) / edges.size
            
            # Convert to 0-100 scale
            # Good text typically has 5-15% edge density
            if 0.05 <= edge_density <= 0.15:
                text_clarity = 100.0
            elif 0.02 <= edge_density <= 0.25:
                text_clarity = 70.0
            else:
                text_clarity = 40.0
            
            return text_clarity
            
        except Exception as e:
            self.logger.warning(f"Error assessing text clarity: {e}")
            return 50.0
    
    def _assess_brightness(self, gray_image: np.ndarray) -> float:
        """Assess image brightness"""
        try:
            mean_brightness = np.mean(gray_image)
            
            # Optimal brightness is around 120-150 (out of 255)
            if 100 <= mean_brightness <= 180:
                brightness_score = 100.0
            elif 50 <= mean_brightness <= 220:
                brightness_score = 70.0
            else:
                brightness_score = 40.0
            
            return brightness_score
            
        except Exception as e:
            self.logger.warning(f"Error assessing brightness: {e}")
            return 50.0
    
    def _detect_skew(self, gray_image: np.ndarray) -> float:
        """Detect document skew angle"""
        try:
            # Apply edge detection
            edges = cv2.Canny(gray_image, 50, 150, apertureSize=3)
            
            # Apply Hough Line Transform
            lines = cv2.HoughLines(edges, 1, np.pi/180, threshold=100)
            
            if lines is None:
                return 0.0
            
            # Calculate angles
            angles = []
            for line in lines:
                rho, theta = line[0]
                angle = theta * 180 / np.pi
                
                # Convert to -90 to 90 range
                if angle > 90:
                    angle = angle - 180
                
                angles.append(angle)
            
            if not angles:
                return 0.0
            
            # Find the most common angle (mode)
            angle_hist, angle_bins = np.histogram(angles, bins=180, range=(-90, 90))
            skew_angle = angle_bins[np.argmax(angle_hist)]
            
            return skew_angle
            
        except Exception as e:
            self.logger.warning(f"Error detecting skew: {e}")
            return 0.0
    
    def _assess_noise(self, gray_image: np.ndarray) -> float:
        """Assess image noise level"""
        try:
            # Apply Gaussian blur and calculate difference
            blurred = cv2.GaussianBlur(gray_image, (5, 5), 0)
            noise = cv2.absdiff(gray_image, blurred)
            
            # Calculate noise level
            noise_level = np.mean(noise)
            
            # Convert to 0-100 scale (lower noise = higher score)
            noise_score = max(0, 100 - (noise_level / 20) * 100)
            
            return min(100, noise_score)
            
        except Exception as e:
            self.logger.warning(f"Error assessing noise: {e}")
            return 50.0
    
    def get_processing_recommendation(self, metrics: QualityMetrics) -> Dict[str, Any]:
        """Get processing recommendations based on quality metrics"""
        recommendations = {
            'processing_tier': 'low_quality',
            'enhancement_needed': True,
            'ocr_engine': 'manual_review',
            'estimated_accuracy': 60,
            'enhancement_suggestions': []
        }
        
        score = metrics.overall_score
        
        if score >= self.config.QUALITY_THRESHOLD_HIGH:
            recommendations.update({
                'processing_tier': 'high_quality',
                'enhancement_needed': False,
                'ocr_engine': 'huggingface_donut',
                'estimated_accuracy': 95
            })
        elif score >= self.config.QUALITY_THRESHOLD_MEDIUM:
            recommendations.update({
                'processing_tier': 'medium_quality',
                'enhancement_needed': True,
                'ocr_engine': 'google_vision',
                'estimated_accuracy': 85
            })
        
        # Specific enhancement suggestions
        if metrics.blur_score < 50:
            recommendations['enhancement_suggestions'].append('sharpen_image')
        
        if metrics.contrast_score < 50:
            recommendations['enhancement_suggestions'].append('enhance_contrast')
        
        if metrics.brightness_score < 50:
            recommendations['enhancement_suggestions'].append('adjust_brightness')
        
        if abs(metrics.skew_angle) > 2:
            recommendations['enhancement_suggestions'].append('correct_skew')
        
        if metrics.noise_level > 70:
            recommendations['enhancement_suggestions'].append('denoise_image')
        
        return recommendations
    
    def assess_document_quality(self, document: Document) -> Document:
        """Assess quality for a document and update its metrics"""
        try:
            # For now, assess the first image/page
            # In a full implementation, you might assess all pages
            image_paths = self._get_image_paths(document)
            
            if not image_paths:
                # No images to assess, assign default low quality
                document.quality_metrics = QualityMetrics(
                    overall_score=30.0,
                    blur_score=30.0,
                    contrast_score=30.0,
                    resolution_score=30.0,
                    text_clarity_score=30.0,
                    brightness_score=50.0,
                    skew_angle=0.0,
                    noise_level=50.0
                )
            else:
                # Assess first image
                document.quality_metrics = self.assess_quality(image_paths[0])
            
            # Set processing tier based on quality
            document.processing_tier = document.get_quality_tier()
            
            # Add processing step
            document.add_processing_step('quality_assessment', {
                'overall_score': document.quality_metrics.overall_score,
                'processing_tier': document.processing_tier.value,
                'recommendations': self.get_processing_recommendation(document.quality_metrics)
            })
            
            self.logger.info(f"Quality assessment completed for document {document.id}", {
                'score': document.quality_metrics.overall_score,
                'tier': document.processing_tier.value
            })
            
            return document
            
        except Exception as e:
            self.logger.error(f"Error in document quality assessment: {e}")
            # Set default low quality on error
            document.quality_metrics = QualityMetrics(
                overall_score=25.0,
                blur_score=25.0,
                contrast_score=25.0,
                resolution_score=25.0,
                text_clarity_score=25.0,
                brightness_score=50.0,
                skew_angle=0.0,
                noise_level=50.0
            )
            document.processing_tier = document.get_quality_tier()
            return document
    
    def _get_image_paths(self, document: Document) -> list:
        """Get image paths for quality assessment"""
        # This would typically convert the document to images first
        # For now, return the document path if it's an image
        file_extension = document.file_path.split('.')[-1].lower()
        
        if file_extension in ['jpg', 'jpeg', 'png', 'tiff', 'bmp']:
            return [document.file_path]
        else:
            # For PDFs and other formats, would need conversion first
            return []
