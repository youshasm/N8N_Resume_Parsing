# Generated by Copilot
# In-memory storage client - No Redis dependency
import json
import logging
from typing import Optional, Any, Dict, List
from datetime import datetime, timedelta

# Setup basic logging for this module
logger = logging.getLogger(__name__)

class InMemoryClient:
    """Simple in-memory storage client - no Redis dependency"""
    
    def __init__(self):
        logger.info("Using in-memory storage client - no external dependencies")
        self._data = {}  # In-memory storage for testing
        self._queues = {}  # Queue storage
        self._counters = {}  # Counter storage
        
    def connect(self) -> bool:
        """Simulate connection for compatibility"""
        logger.info("In-memory client 'connected' successfully")
        return True
        
    def close(self):
        """Simulate disconnection for compatibility"""
        logger.info("In-memory client 'disconnected'")
        
    def is_connected(self) -> bool:
        """Check if connected"""
        return True
        
    def ping(self) -> bool:
        """Simulate ping for compatibility"""
        return True
        
    def set(self, key: str, value: Any, ex: Optional[int] = None) -> bool:
        """Store data in memory"""
        self._data[key] = {
            'value': json.dumps(value) if not isinstance(value, str) else value,
            'expires_at': datetime.now() + timedelta(seconds=ex) if ex else None
        }
        return True
        
    def get(self, key: str) -> Optional[str]:
        """Retrieve data from memory"""
        if key not in self._data:
            return None
            
        item = self._data[key]
        if item['expires_at'] and datetime.now() > item['expires_at']:
            del self._data[key]
            return None
            
        return item['value']
    
    def delete(self, key: str) -> int:
        """Delete key from memory"""
        if key in self._data:
            del self._data[key]
            return 1
        return 0
    
    def exists(self, key: str) -> bool:
        """Check if key exists"""
        if key in self._data:
            item = self._data[key]
            if item['expires_at'] and datetime.now() > item['expires_at']:
                del self._data[key]
                return False
            return True
        return False
    
    # Queue operations
    def add_to_queue(self, queue_name: str, item: Dict[str, Any]) -> bool:
        """Add item to queue"""
        if queue_name not in self._queues:
            self._queues[queue_name] = []
        self._queues[queue_name].append(json.dumps(item))
        return True
    
    def get_from_queue(self, queue_name: str) -> Optional[Dict[str, Any]]:
        """Get item from queue"""
        if queue_name not in self._queues or not self._queues[queue_name]:
            return None
        item_str = self._queues[queue_name].pop(0)
        return json.loads(item_str)
    
    def get_queue_length(self, queue_name: str) -> int:
        """Get queue length"""
        return len(self._queues.get(queue_name, []))
    
    def get_all_queue_lengths(self) -> Dict[str, int]:
        """Get all queue lengths"""
        return {name: len(queue) for name, queue in self._queues.items()}
    
    # Counter operations
    def increment_counter(self, counter_name: str, amount: int = 1) -> int:
        """Increment counter"""
        if counter_name not in self._counters:
            self._counters[counter_name] = 0
        self._counters[counter_name] += amount
        return self._counters[counter_name]
    
    def get_counter(self, counter_name: str) -> int:
        """Get counter value"""
        return self._counters.get(counter_name, 0)
    
    def get_all_counters(self) -> Dict[str, int]:
        """Get all counters"""
        return self._counters.copy()
    
    # Document caching
    def cache_document_metadata(self, file_hash: str, data: Dict[str, Any], ttl: int = 3600) -> bool:
        """Cache document metadata"""
        return self.set(f"doc_meta:{file_hash}", json.dumps(data), ex=ttl)
    
    def get_cached_document(self, file_hash: str) -> Optional[Dict[str, Any]]:
        """Get cached document metadata"""
        cached = self.get(f"doc_meta:{file_hash}")
        if cached:
            try:
                return json.loads(cached)
            except json.JSONDecodeError:
                return None
        return None
    
    # Statistics
    def get_processing_stats(self) -> Dict[str, Any]:
        """Get processing statistics"""
        stats = {
            'total_keys': len(self._data),
            'total_queues': len(self._queues),
            'total_counters': len(self._counters),
            'counters': self._counters.copy(),
            'queue_lengths': self.get_all_queue_lengths()
        }
        return stats
    
    def get_redis_info(self) -> Dict[str, str]:
        """Get client info"""
        return {
            "status": "in-memory", 
            "type": "InMemoryClient", 
            "data_keys": len(self._data),
            "total_queues": len(self._queues),
            "total_counters": len(self._counters)
        }

# Global in-memory client instance
redis_client = InMemoryClient()
