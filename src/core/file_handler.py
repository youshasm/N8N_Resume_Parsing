# Generated by Copilot
import os
import hashlib
from pathlib import Path
from typing import Optional, Tuple
import uuid
import shutil
from PIL import Image
import fitz  # PyMuPDF
from docx2txt import process as docx_process
import mimetypes

# Windows-compatible magic import
try:
    import magic
    MAGIC_AVAILABLE = True
except ImportError:
    MAGIC_AVAILABLE = False
    magic = None

from ..models.document import Document
from ..utils.config import Config
from ..utils.logger import Logger

class FileHandler:
    """Handles file operations, validation, and format conversion"""
    
    def __init__(self):
        self.logger = Logger(__name__)
        self.config = Config()
        self._ensure_directories()
    
    def _ensure_directories(self):
        """Ensure all required directories exist"""
        directories = [
            self.config.UPLOAD_FOLDER,
            self.config.TEMP_FOLDER,
            self.config.PROCESSED_FOLDER
        ]
        
        for directory in directories:
            os.makedirs(directory, exist_ok=True)
            self.logger.debug(f"Ensured directory exists: {directory}")
    
    def validate_file(self, file_path: str) -> Tuple[bool, str]:
        """
        Validate uploaded file
        Returns: (is_valid, error_message)
        """
        try:
            if not os.path.exists(file_path):
                return False, "File does not exist"
            
            # Check file size
            file_size_mb = os.path.getsize(file_path) / (1024 * 1024)
            if file_size_mb > self.config.MAX_FILE_SIZE_MB:
                return False, f"File size ({file_size_mb:.1f}MB) exceeds limit ({self.config.MAX_FILE_SIZE_MB}MB)"
              # Check file extension
            file_extension = Path(file_path).suffix.lower()
            if not self.config.is_supported_format(file_extension):
                return False, f"Unsupported file format: {file_extension}"
            
            # Check MIME type - use magic if available, otherwise use mimetypes
            try:
                if MAGIC_AVAILABLE:
                    mime_type = magic.from_file(file_path, mime=True)
                else:
                    mime_type, _ = mimetypes.guess_type(file_path)
                    if not mime_type:
                        mime_type = "application/octet-stream"
                self.logger.debug(f"Detected MIME type: {mime_type}")
            except Exception as e:
                self.logger.warning(f"Could not determine MIME type: {e}")
                mime_type = "application/octet-stream"
            
            # Additional validation for images
            if file_extension in self.config.SUPPORTED_IMAGE_FORMATS:
                try:
                    with Image.open(file_path) as img:
                        # Check minimum dimensions
                        if img.width < 100 or img.height < 100:
                            return False, "Image dimensions too small (minimum 100x100)"
                except Exception as e:
                    return False, f"Invalid image file: {e}"
            
            return True, "File validation successful"
            
        except Exception as e:
            self.logger.error(f"File validation error: {e}")
            return False, f"Validation error: {e}"
    
    def save_uploaded_file(self, source_path: str, original_filename: str) -> Document:
        """
        Save uploaded file and create Document object
        """
        try:
            # Generate unique filename
            file_extension = Path(original_filename).suffix.lower()
            unique_id = str(uuid.uuid4())[:8]
            safe_filename = f"{unique_id}_{self._sanitize_filename(original_filename)}"
            
            # Destination path
            dest_path = os.path.join(self.config.UPLOAD_FOLDER, safe_filename)
            
            # Copy file to upload directory
            shutil.copy2(source_path, dest_path)
            
            # Create Document object
            document = Document(dest_path, original_filename)
            document.file_size_bytes = os.path.getsize(dest_path)
            document.mime_type = magic.from_file(dest_path, mime=True)
            
            # Calculate file hash for deduplication
            file_hash = self._calculate_file_hash(dest_path)
            document.add_processing_step('file_upload', {
                'file_hash': file_hash,
                'file_size': document.file_size_bytes,
                'mime_type': document.mime_type,
                'saved_path': dest_path
            })
            
            self.logger.info(f"File saved successfully: {safe_filename}")
            return document
            
        except Exception as e:
            self.logger.error(f"Error saving uploaded file: {e}")
            raise
    
    def convert_to_images(self, document: Document) -> list:
        """
        Convert document to images for processing
        Returns list of image paths
        """
        try:
            file_extension = Path(document.file_path).suffix.lower()
            images = []
            
            if file_extension in self.config.SUPPORTED_IMAGE_FORMATS:
                # Already an image
                images.append(document.file_path)
                
            elif file_extension == '.pdf':
                # Convert PDF to images
                images = self._pdf_to_images(document)
                
            elif file_extension in ['.doc', '.docx']:
                # For Word documents, we'll process text directly
                # But create a placeholder for consistency
                images.append(document.file_path)
                
            document.add_processing_step('format_conversion', {
                'original_format': file_extension,
                'converted_images': len(images),
                'image_paths': images
            })
            
            return images
            
        except Exception as e:
            self.logger.error(f"Error converting document to images: {e}")
            raise
    
    def _pdf_to_images(self, document: Document) -> list:
        """Convert PDF pages to images"""
        try:
            pdf_document = fitz.open(document.file_path)
            images = []
            
            for page_num in range(len(pdf_document)):
                page = pdf_document[page_num]
                
                # Render page as image (150 DPI for good quality)
                mat = fitz.Matrix(2.0, 2.0)  # 2x zoom = ~150 DPI
                pix = page.get_pixmap(matrix=mat)
                
                # Save as PNG
                base_name = Path(document.file_path).stem
                image_path = os.path.join(
                    self.config.TEMP_FOLDER,
                    f"{base_name}_page_{page_num + 1}.png"
                )
                
                pix.save(image_path)
                images.append(image_path)
                
                self.logger.debug(f"Converted PDF page {page_num + 1} to {image_path}")
            
            pdf_document.close()
            return images
            
        except Exception as e:
            self.logger.error(f"Error converting PDF to images: {e}")
            raise
    
    def extract_text_from_docx(self, file_path: str) -> str:
        """Extract text from DOCX files"""
        try:
            text = docx_process(file_path)
            return text.strip()
        except Exception as e:
            self.logger.error(f"Error extracting text from DOCX: {e}")
            return ""
    
    def split_merged_pdf(self, document: Document) -> list:
        """
        Split merged PDF into individual documents
        Returns list of new Document objects
        """
        try:
            pdf_document = fitz.open(document.file_path)
            split_documents = []
            
            if len(pdf_document) <= 1:
                # Single page PDF, no splitting needed
                return [document]
            
            for page_num in range(len(pdf_document)):
                # Create new PDF with single page
                new_pdf = fitz.open()
                new_pdf.insert_pdf(pdf_document, from_page=page_num, to_page=page_num)
                
                # Save split PDF
                base_name = Path(document.original_filename).stem
                split_filename = f"{base_name}_page_{page_num + 1}.pdf"
                split_path = os.path.join(self.config.TEMP_FOLDER, split_filename)
                
                new_pdf.save(split_path)
                new_pdf.close()
                
                # Create new Document object
                split_doc = Document(split_path, split_filename)
                split_doc.file_size_bytes = os.path.getsize(split_path)
                split_doc.mime_type = "application/pdf"
                split_doc.add_processing_step('pdf_split', {
                    'parent_document_id': document.id,
                    'page_number': page_num + 1,
                    'total_pages': len(pdf_document)
                })
                
                split_documents.append(split_doc)
                self.logger.debug(f"Created split document: {split_filename}")
            
            pdf_document.close()
            
            # Update original document
            document.add_processing_step('pdf_split', {
                'total_pages': len(pdf_document),
                'split_documents': len(split_documents)
            })
            
            return split_documents
            
        except Exception as e:
            self.logger.error(f"Error splitting PDF: {e}")
            return [document]  # Return original if splitting fails
    
    def _sanitize_filename(self, filename: str) -> str:
        """Sanitize filename for safe storage"""
        # Remove path separators and other problematic characters
        safe_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_"
        sanitized = "".join(c for c in filename if c in safe_chars)
        
        # Ensure filename is not empty and not too long
        if not sanitized:
            sanitized = "document"
        
        if len(sanitized) > 100:
            name_part = sanitized[:90]
            ext_part = sanitized[-10:] if '.' in sanitized[-10:] else ""
            sanitized = name_part + ext_part
        
        return sanitized
    
    def _calculate_file_hash(self, file_path: str) -> str:
        """Calculate MD5 hash of file for deduplication"""
        hash_md5 = hashlib.md5()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    
    def cleanup_temp_files(self, file_paths: list):
        """Clean up temporary files"""
        for file_path in file_paths:
            try:
                if os.path.exists(file_path) and self.config.TEMP_FOLDER in file_path:
                    os.remove(file_path)
                    self.logger.debug(f"Cleaned up temp file: {file_path}")
            except Exception as e:
                self.logger.warning(f"Could not clean up temp file {file_path}: {e}")
    
    def move_to_processed(self, document: Document) -> str:
        """Move processed document to processed folder"""
        try:
            processed_path = os.path.join(
                self.config.PROCESSED_FOLDER,
                os.path.basename(document.file_path)
            )
            
            shutil.move(document.file_path, processed_path)
            document.file_path = processed_path
            
            document.add_processing_step('file_moved', {
                'moved_to': processed_path,
                'status': 'processed'
            })
            
            self.logger.info(f"Document moved to processed folder: {processed_path}")
            return processed_path
            
        except Exception as e:
            self.logger.error(f"Error moving document to processed folder: {e}")
            return document.file_path
