# Generated by Copilot
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any
import uuid

class DocumentType(Enum):
    """Document type enumeration"""
    CV_RESUME = "cv_resume"
    PASSPORT = "passport"
    EDUCATION_CERTIFICATE = "education_certificate"
    EXPERIENCE_LETTER = "experience_letter"
    NATIONAL_ID = "national_id"
    MEDICAL_CERTIFICATE = "medical_certificate"
    TRAINING_CERTIFICATE = "training_certificate"
    REFERENCE_LETTER = "reference_letter"
    UNKNOWN = "unknown"

class ProcessingTier(Enum):
    """Processing tier based on quality score"""
    HIGH_QUALITY = "high_quality"  # Quality >= 75
    MEDIUM_QUALITY = "medium_quality"  # Quality 50-74
    LOW_QUALITY = "low_quality"  # Quality < 50

class ProcessingStatus(Enum):
    """Document processing status"""
    UPLOADED = "uploaded"
    QUALITY_ASSESSED = "quality_assessed"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    REQUIRES_HUMAN_REVIEW = "requires_human_review"

@dataclass
class QualityMetrics:
    """Quality assessment metrics"""
    overall_score: float  # 0-100
    blur_score: float
    contrast_score: float
    resolution_score: float
    text_clarity_score: float
    brightness_score: float
    skew_angle: float
    noise_level: float
    
class ExtractedField:
    """Represents an extracted field with confidence"""
    def __init__(self, value: str, confidence: float, source_region: Optional[Dict] = None):
        self.value = value
        self.confidence = confidence
        self.source_region = source_region  # Bounding box coordinates
        self.manual_verified = False
        self.extracted_at = datetime.now()

@dataclass
class ProcessingResult:
    """Complete processing result for a document"""
    document_id: str
    classification: DocumentType
    quality_score: float
    processing_tier: ProcessingTier
    ocr_engine_used: str
    processing_cost: float
    confidence: float
    extracted_data: Dict[str, ExtractedField]
    processing_time_seconds: float
    status: ProcessingStatus
    error_message: Optional[str] = None
    
class Document:
    """Main document class"""
    def __init__(self, file_path: str, original_filename: str):
        self.id = str(uuid.uuid4())
        self.file_path = file_path
        self.original_filename = original_filename
        self.uploaded_at = datetime.now()
        self.file_size_bytes: Optional[int] = None
        self.mime_type: Optional[str] = None
        
        # Processing attributes
        self.document_type: Optional[DocumentType] = None
        self.quality_metrics: Optional[QualityMetrics] = None
        self.processing_tier: Optional[ProcessingTier] = None
        self.status = ProcessingStatus.UPLOADED
        
        # Results
        self.extracted_data: Dict[str, ExtractedField] = {}
        self.processing_cost = 0.0
        self.processing_history: List[Dict] = []
        
    def add_processing_step(self, step_name: str, details: Dict[str, Any]):
        """Add a processing step to history"""
        self.processing_history.append({
            'step': step_name,
            'timestamp': datetime.now().isoformat(),
            'details': details
        })
    
    def get_quality_tier(self) -> ProcessingTier:
        """Determine processing tier based on quality score"""
        if not self.quality_metrics:
            return ProcessingTier.LOW_QUALITY
            
        score = self.quality_metrics.overall_score
        if score >= 75:
            return ProcessingTier.HIGH_QUALITY
        elif score >= 50:
            return ProcessingTier.MEDIUM_QUALITY
        else:
            return ProcessingTier.LOW_QUALITY
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert document to dictionary for serialization"""
        return {
            'id': self.id,
            'file_path': self.file_path,
            'original_filename': self.original_filename,
            'uploaded_at': self.uploaded_at.isoformat(),
            'file_size_bytes': self.file_size_bytes,
            'mime_type': self.mime_type,
            'document_type': self.document_type.value if self.document_type else None,
            'quality_metrics': self.quality_metrics.__dict__ if self.quality_metrics else None,
            'processing_tier': self.processing_tier.value if self.processing_tier else None,
            'status': self.status.value,
            'extracted_data': {
                key: {
                    'value': field.value,
                    'confidence': field.confidence,
                    'source_region': field.source_region,
                    'manual_verified': field.manual_verified,
                    'extracted_at': field.extracted_at.isoformat()
                } for key, field in self.extracted_data.items()
            },
            'processing_cost': self.processing_cost,
            'processing_history': self.processing_history
        }
