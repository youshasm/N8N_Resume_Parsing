{
  "nodes": [
    {
      "parameters": {
        "content": "## AI",
        "height": 368,
        "width": 480,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        2288,
        -192
      ],
      "typeVersion": 1,
      "id": "95f93019-cf17-450c-9560-58caa21d4965",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "content": "## File Format Classification",
        "height": 224,
        "width": 816,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -520,
        -132
      ],
      "typeVersion": 1,
      "id": "a2914239-a690-4f69-932a-6bdc72237dc7",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d505e596-8a4b-4118-adac-5c1be8492a60",
              "name": "original_filename",
              "value": "={{ $json.data.original_filename }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        176,
        -68
      ],
      "id": "71fcd118-b38a-4d94-8d41-99c402ffa326",
      "name": "Edit Fields1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "5d5e8589-09d6-4b11-b17a-e29fb8f032db",
              "name": "original_filename",
              "value": "={{ $json.file[0].filename }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -272,
        -260
      ],
      "id": "edf4592c-5bd2-4073-bbb0-0008675b68d2",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced classification logic with binary data preservation\nconst items = $input.all();\nconst processedItems = [];\n\nfunction extractFilename(data) {\n  if (data.converted_pdf) return data.converted_pdf.split(/[\\/]/).pop();\n  if (data.converted_docx) return data.converted_docx.split(/[\\/]/).pop();\n  if (data.original_filename && data.original_filename !== 'undefined' && data.original_filename !== 'null') return data.original_filename;\n  if (data.fileName) return data.fileName;\n  if (data.filename) return data.filename;\n  if (data.name) return data.name;\n  if (Array.isArray(data.file) && data.file.length > 0 && data.file[0].filename) return data.file[0].filename;\n  if (data.document_id) return `document_${data.document_id}.pdf`;\n  return 'document_unknown.pdf';\n}\n\nfunction preserveBinaryData(item) {\n  // Preserve all binary data properties\n  if (item.binary) {\n    return { ...item.binary };\n  }\n  return null;\n}\n\nfunction detectType(filename, mimetype) {\n  const ext = filename.split('.').pop()?.toLowerCase();\n  // Prefer mimetype if it is very specific\n  if (mimetype) {\n    const mt = mimetype.toLowerCase();\n    if (mt.includes('officedocument.wordprocessingml.document')) return 'docx';\n    if (mt.includes('msword')) {\n      // Some browsers send .docx as msword, so check extension\n      if (ext === 'docx') return 'docx';\n      return 'doc';\n    }\n    if (mt.includes('pdf')) return 'pdf';\n    if (mt.includes('image')) return 'image';\n  }\n  // Fallback to extension\n  if (ext === 'docx') return 'docx';\n  if (ext === 'doc') return 'doc';\n  if (ext === 'pdf') return 'pdf';\n  if (['jpg','jpeg','png'].includes(ext)) return 'image';\n  return 'unknown';\n}\n\nfor (const item of items) {\n  const data = item.json;\n  const documentId = data.document_id;\n  const mimetype = data.mimeType || data.mimetype || (Array.isArray(data.file) && data.file.length > 0 && data.file[0].mimetype) || undefined;\n  const preferredFilename = extractFilename(data);\n  const detectedType = detectType(preferredFilename, mimetype);\n  const qualityScore = data.quality_score || 0;\n  const confidence = data.confidence || 0;\n  let classificationFactors = [];\n  let processingRequirements = [];\n  if (detectedType === 'pdf') {\n    classificationFactors.push('PDF document detected');\n    processingRequirements.push('OCR processing', 'Text extraction');\n  } else if (detectedType === 'docx') {\n    classificationFactors.push('DOCX document detected');\n    processingRequirements.push('Direct text extraction', 'Format parsing');\n  } else if (detectedType === 'doc') {\n    classificationFactors.push('DOC document detected');\n    processingRequirements.push('Convert to DOCX', 'Direct text extraction');\n  } else if (detectedType === 'image') {\n    classificationFactors.push('Image document detected');\n    processingRequirements.push('OCR processing', 'Image enhancement');\n  } else {\n    classificationFactors.push('Unknown document type');\n    processingRequirements.push('Manual review');\n  }\n  if (qualityScore >= 0.8) {\n    classificationFactors.push('High quality document');\n    processingRequirements.push('Standard processing');\n  } else if (qualityScore >= 0.5) {\n    classificationFactors.push('Medium quality document');\n    processingRequirements.push('Enhanced processing', 'Quality improvement');\n  } else {\n    classificationFactors.push('Low quality document');\n    processingRequirements.push('Manual review', 'Quality enhancement');\n  }\n  const filename = preferredFilename.toLowerCase();\n  let subType = 'general';\n  if (filename.includes('cv') || filename.includes('resume')) {\n    classificationFactors.push('Resume/CV document identified');\n    processingRequirements.push('Personal info extraction', 'Skills parsing');\n    subType = 'resume';\n  } else if (filename.includes('application')) {\n    classificationFactors.push('Application form identified');\n    processingRequirements.push('Form field extraction', 'Structured data parsing');\n    subType = 'application_form';\n  } else if (filename.includes('certificate')) {\n    subType = 'certificate';\n  }\n  processedItems.push({\n    json: {\n      document_id: documentId,\n      document_type: detectedType,\n      sub_type: subType,\n      confidence: confidence,\n      classification_factors: classificationFactors,\n      processing_requirements: processingRequirements,\n      original_filename: preferredFilename,\n      quality_score: qualityScore,\n      classification_metadata: {\n        source_filename: preferredFilename,\n        detected_extension: preferredFilename.split('.').pop()?.toLowerCase(),\n        original_type: data.document_type || 'unknown',\n        final_type: detectedType,\n        mimetype: mimetype\n      }\n    }\n  });\n}\n\nreturn processedItems;"
      },
      "id": "d6264412-ff12-45f3-9954-b0677ada3c3f",
      "name": "Classification Engine1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        -68
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced file type classification with better detection\nconst items = $input.all();\nconst processedItems = [];\n\nfunction detectFormat(documentType, filename, mimetype) {\n  // Priority 1: Use backend classification if reliable\n  if (documentType && documentType !== 'unknown') {\n    return documentType;\n  }\n  \n  // Priority 2: MIME type analysis\n  if (mimetype) {\n    const mimeType = mimetype.toLowerCase();\n    if (mimeType.includes('pdf')) return 'pdf';\n    if (mimeType.includes('msword') || mimeType.includes('word')) return 'doc';\n    if (mimeType.includes('officedocument.wordprocessingml.document')) return 'docx';\n    if (mimeType.includes('image')) {\n      if (mimeType.includes('jpeg') || mimeType.includes('jpg')) return 'jpg';\n      if (mimeType.includes('png')) return 'png';\n      return 'image';\n    }\n  }\n  \n  // Priority 3: Filename extension\n  if (filename) {\n    const ext = filename.split('.').pop()?.toLowerCase();\n    const validExtensions = ['pdf', 'doc', 'docx', 'jpg', 'jpeg', 'png'];\n    if (validExtensions.includes(ext)) {\n      return ext === 'jpeg' ? 'jpg' : ext;\n    }\n  }\n  \n  return 'unknown';\n}\n\nfor (const item of items) {\n  const data = item.json;\n  \n  const documentType = data.document_type;\n  const filename = data.original_filename || data.fileName || data.filename;\n  const mimetype = data.mimeType || data.mimetype;\n  \n  const format = detectFormat(documentType, filename, mimetype);\n  \n  // Add additional metadata for processing\n  const result = {\n    json: {\n      ...data, // Preserve all original data\n      format: format,\n      file_extension: filename ? filename.split('.').pop()?.toLowerCase() : null,\n      mime_type: mimetype,\n      classification_complete: true,\n      processing_ready: format !== 'unknown',\n      // Ensure filename is preserved\n      original_filename: filename || `document_${data.document_id || 'unknown'}`,\n      // Add debugging info\n      format_detection: {\n        input_type: documentType,\n        input_filename: filename,\n        input_mimetype: mimetype,\n        final_format: format\n      }\n    }\n  };\n  \n  processedItems.push(result);\n}\n\nreturn processedItems;"
      },
      "id": "bc3cba05-1b97-4d1d-bde7-25cbc7a21a7f",
      "name": "Classify File Type1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        -68
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.document_type }}",
                    "rightValue": "doc",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "30e3bc04-df43-4991-976f-5d54389e6854"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "8b5d390e-d2e6-4180-8bde-b5f9e6c18698",
                    "leftValue": "={{ $json.document_type }}",
                    "rightValue": "docx",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "3e126769-faf2-4943-859e-abe29e904eb0",
                    "leftValue": "={{ $json.document_type }}",
                    "rightValue": "pdf",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a7951a45-f1ca-4cea-89a9-b44027f36cf1",
                    "leftValue": "={{ $json.document_type }}",
                    "rightValue": "image",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        624,
        -196
      ],
      "id": "a885f997-f1d1-4f2d-abd7-5f27f9c7894d",
      "name": "Switch1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://imp-fastapi:8000/api/documents/upload",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "file"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "file"
            }
          }
        }
      },
      "id": "0f71ecdb-9768-44f5-9452-9b054653f450",
      "name": "Convert DOCX to PDF (FastAPI)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        848,
        -92
      ],
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        400,
        -164
      ],
      "id": "a89b9304-a8ed-43fa-8aaa-0f1a69ffa6f0",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "// Split experience and education data into individual entries for ERPNext\n// Fixed to handle actual data structure from Resume Parser\nconst items = $input.all();\nconst result = [];\n\nconsole.log(`Split Experience and Education Data received ${items.length} items`);\n\nfor (const item of items) {\n  const jobApplicantData = item.json;\n  \n  // Log all available fields for debugging\n  console.log(`Job Applicant Data Keys: ${Object.keys(jobApplicantData).join(', ')}`);\n  \n  // Use the correct experience array - the experience array is already in the right format\n  const experienceArray = jobApplicantData.experience || [];\n  const educationArray = jobApplicantData.qualification_block || jobApplicantData.educational_qualification || [];\n  \n  // Get the ERPNext document identifiers from the created Job Applicant\n  const documentName = jobApplicantData.name; // ERPNext document name\n  const registrationNumber = jobApplicantData.imp_registration_number; // Custom field\n  const applicantName = jobApplicantData.applicant_name; // Applicant's actual name\n  \n  // Debug: Log the captured identifiers\n  console.log(`Captured Document Name: ${documentName}`);\n  console.log(`Captured Registration Number: ${registrationNumber}`);\n  console.log(`Captured Applicant Name: ${applicantName}`);\n  console.log(`Experience Array Length: ${experienceArray.length}`);\n  console.log(`Education Array Length: ${educationArray.length}`);\n  \n  // Log sample data to understand structure\n  if (experienceArray.length > 0) {\n    console.log(`Sample Experience Data:`, JSON.stringify(experienceArray[0], null, 2));\n  }\n  if (educationArray.length > 0) {\n    console.log(`Sample Education Data:`, JSON.stringify(educationArray[0], null, 2));\n  }\n  \n  // Check if we have valid experience data - handle the actual structure\n  const hasValidExperience = Array.isArray(experienceArray) && \n    experienceArray.length > 0 && \n    experienceArray.some(exp => {\n      const company = exp.company || exp.experience_institution || '';\n      const title = exp.designation || exp.experience_title || '';\n      return (company.trim() !== '' && company !== 'Not Specified') ||\n             (title.trim() !== '' && title !== 'Not Specified');\n    });\n  \n  // Check if we have valid education data\n  const hasValidEducation = Array.isArray(educationArray) && \n    educationArray.length > 0 && \n    educationArray.some(edu => {\n      const degree = edu.degree_name || edu.degree || '';\n      const institution = edu.institution_name || edu.institution || '';\n      return (degree.trim() !== '' && degree !== 'Not Specified') ||\n             (institution.trim() !== '' && institution !== 'Not Specified');\n    });\n  \n  console.log(`Has Valid Experience: ${hasValidExperience}`);\n  console.log(`Has Valid Education: ${hasValidEducation}`);\n  \n  // Process experience data - handle the existing ERPNext child table format\n  if (hasValidExperience) {\n    console.log(`Processing ${experienceArray.length} experience entries for ${documentName}`);\n    \n    experienceArray.forEach((experience, index) => {\n      // Handle both old and new field formats\n      const company = experience.company || experience.experience_institution || 'Not Specified';\n      const title = experience.designation || experience.experience_title || 'Not Specified';\n      const duration = experience.years_of_experience || '0';\n      const description = experience.experience_description || 'No description provided';\n      \n      if ((company.trim() !== '' && company !== 'Not Specified') ||\n          (title.trim() !== '' && title !== 'Not Specified')) {\n        result.push({\n          json: {\n            data_type: 'experience',\n            job_applicant_document_name: documentName,\n            job_applicant_registration: registrationNumber,\n            job_applicant_name: applicantName,\n            company: company,\n            designation: title,\n            years_of_experience: duration,\n            experience_description: description,\n            from_date: experience.from_date || '1900-01-01',\n            to_date: experience.to_date || '1900-01-01',\n            salary: experience.salary || 0\n          }\n        });\n        \n        console.log(`Added experience entry: ${title} at ${company}`);\n      }\n    });\n  }\n  \n  // Process education data - handle the existing ERPNext child table format\n  if (hasValidEducation) {\n    console.log(`Processing ${educationArray.length} education entries for ${documentName}`);\n    \n    educationArray.forEach((education, index) => {\n      // Handle both old and new field formats\n      const degree = education.degree_name || education.degree || 'Not Specified';\n      const institution = education.institution_name || education.institution || 'Not Specified';\n      const year = education.year_of_passing || education.year || '1900';\n      const grade = education.grade || 'N/A';\n      const level = education.education_level || 'Bachelors';\n      \n      if ((degree.trim() !== '' && degree !== 'Not Specified') ||\n          (institution.trim() !== '' && institution !== 'Not Specified')) {\n        result.push({\n          json: {\n            data_type: 'education',\n            job_applicant_document_name: documentName,\n            job_applicant_registration: registrationNumber,\n            job_applicant_name: applicantName,\n            degree: degree,\n            institution: institution,\n            year_of_passing: year,\n            grade: grade,\n            education_level: level\n          }\n        });\n        \n        console.log(`Added education entry: ${degree} from ${institution}`);\n      }\n    });\n  }\n  \n  if (!hasValidExperience && !hasValidEducation) {\n    console.log(`No valid experience or education found for ${documentName}`);\n  }\n}\n\n// Return results only if we have valid data\nif (result.length === 0) {\n  console.log('No valid experience or education data found - workflow will stop here');\n  return [];\n}\n\nconsole.log(`Returning ${result.length} total entries (experience + education)`);\nreturn result;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6384,
        -572
      ],
      "id": "f3c360fd-d1b8-4cb5-a4c0-72dc2a12470a",
      "name": "Split Experience and Education Data"
    },
    {
      "parameters": {
        "jsCode": "// Collect experience and education data and prepare for Job Applicant update\n// Only process if we have valid data\nconst items = $input.all();\nconst experienceEntries = [];\nconst educationEntries = [];\nlet jobApplicantDocumentName = '';\nlet jobApplicantRegistration = '';\nlet jobApplicantName = '';\n\n// Function to extract years as integer from strings like \"13 years\", \"5 months\", etc.\nfunction extractYearsAsInteger(yearsString) {\n  if (!yearsString || typeof yearsString !== 'string') {\n    return 0;\n  }\n  \n  const numbers = yearsString.match(/\\d+/g);\n  if (!numbers || numbers.length === 0) {\n    return 0;\n  }\n  \n  const value = parseInt(numbers[0]);\n  \n  if (yearsString.toLowerCase().includes('month')) {\n    return Math.round(value / 12 * 10) / 10;\n  }\n  \n  return value;\n}\n\n// Function to map degree names to education levels\nfunction mapEducationLevel(degreeName) {\n  if (!degreeName || typeof degreeName !== 'string') {\n    return 'Bachelors';\n  }\n  \n  const degree = degreeName.toLowerCase();\n  \n  if (degree.includes('matric') || degree.includes('matriculation') || \n      degree.includes('ssc') || degree.includes('secondary school') ||\n      degree.includes('10th') || degree.includes('grade 10')) {\n    return 'Matric';\n  }\n  \n  if (degree.includes('fsc') || degree.includes('f.sc') || degree.includes('intermediate') ||\n      degree.includes('hssc') || degree.includes('higher secondary') ||\n      degree.includes('12th') || degree.includes('grade 12') || degree.includes('pre-med') ||\n      degree.includes('pre-eng') || degree.includes('ics') || degree.includes('i.c.s')) {\n    return 'FSc';\n  }\n  \n  if (degree.includes('diploma') || degree.includes('dae') || degree.includes('d.a.e') ||\n      degree.includes('polytechnic') || degree.includes('technical') ||\n      degree.includes('certificate') || degree.includes('vocational')) {\n    return 'Diploma';\n  }\n  \n  if (degree.includes('master') || degree.includes('m.a') || degree.includes('m.sc') ||\n      degree.includes('mba') || degree.includes('m.b.a') || degree.includes('m.com') ||\n      degree.includes('ms') || degree.includes('m.s') || degree.includes('mphil') ||\n      degree.includes('m.phil') || degree.includes('postgraduate')) {\n    return 'Masters';\n  }\n  \n  if (degree.includes('phd') || degree.includes('ph.d') || degree.includes('doctorate') ||\n      degree.includes('doctoral')) {\n    return 'Masters';\n  }\n  \n  return 'Bachelors';\n}\n\nconsole.log(`Collect Experience and Education Data received ${items.length} items`);\n\nif (items.length === 0) {\n  console.log('No items received - skipping processing');\n  return [];\n}\n\nfor (const item of items) {\n  if (!jobApplicantDocumentName && item.json.job_applicant_document_name) {\n    jobApplicantDocumentName = item.json.job_applicant_document_name;\n  }\n  \n  if (!jobApplicantRegistration && item.json.job_applicant_registration) {\n    jobApplicantRegistration = item.json.job_applicant_registration;\n  }\n  \n  if (!jobApplicantName && item.json.job_applicant_name) {\n    jobApplicantName = item.json.job_applicant_name;\n  }\n  \n  // Process based on data type\n  if (item.json.data_type === 'experience') {\n    experienceEntries.push({\n      experience_title: item.json.designation,\n      years_of_experience: extractYearsAsInteger(item.json.years_of_experience),\n      experience_institution: item.json.company,\n      idx: experienceEntries.length + 1\n    });\n  } else if (item.json.data_type === 'education') {\n    const educationLevel = mapEducationLevel(item.json.degree);\n    \n    educationEntries.push({\n      education_level: educationLevel,\n      degree_name: item.json.degree,\n      institution_name:item.json.institution,\n      idx: educationEntries.length + 1\n    });\n    \n    console.log(`Mapped degree '${item.json.degree}' to education level '${educationLevel}'`);\n  }\n}\n\nconsole.log(`Collected identifiers:`);\nconsole.log(`- Document Name: ${jobApplicantDocumentName}`);\nconsole.log(`- Registration: ${jobApplicantRegistration}`);\nconsole.log(`- Applicant Name: ${jobApplicantName}`);\nconsole.log(`- Experience Entries: ${experienceEntries.length}`);\nconsole.log(`- Education Entries: ${educationEntries.length}`);\n\nreturn [{\n  json: {\n    job_applicant_document_name: jobApplicantDocumentName,\n    job_applicant_registration: jobApplicantRegistration,\n    job_applicant_name: jobApplicantName,\n    experience_certifications: experienceEntries,\n    educational_qualification: educationEntries,\n    total_experience_entries: experienceEntries.length,\n    total_education_entries: educationEntries.length,\n    processing_note: `Processing ${experienceEntries.length} experience and ${educationEntries.length} education entries for document: ${jobApplicantDocumentName}`\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6608,
        -572
      ],
      "id": "bc18da56-ff90-4163-ae62-5fe3b7952566",
      "name": "Collect Experience and Education Data"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        6832,
        -500
      ],
      "id": "429dc274-4f4e-4d89-b63f-1462b9fb51a4",
      "name": "Merge Job Applicant Experience and Education"
    },
    {
      "parameters": {
        "jsCode": "// Extract just the fieldnames from the doctype response\nconst response = $input.all()[0].json;\n\n// Handle different response structures\nlet fields = [];\n\n// Try to get fields from different possible response structures\nif (response.message?.docs?.[0]?.fields) {\n  fields = response.message.docs[0].fields;\n} else if (response.docs?.[0]?.fields) {\n  fields = response.docs[0].fields;\n} else if (Array.isArray(response.fields)) {\n  fields = response.fields;\n}\n\nif (fields.length > 0) {\n  const fieldnames = fields.map(field => field.fieldname).filter(name => name);\n  return [{\n    json: {\n      fieldnames: fieldnames,\n      total_fields: fieldnames.length\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    error: 'Could not retrieve field information',\n    response: response,\n    tip: 'Please check if you are properly authenticated and have permissions to access the Job Applicant doctype'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        -452
      ],
      "name": "Get Field Names",
      "id": "005cc620-1e22-46c7-9b28-2275e8945be4"
    },
    {
      "parameters": {
        "url": "https://app.alphaworkforce.org/api/method/frappe.desk.form.load.getdoctype?doctype=Job%20Applicant",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "erpNextApi",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -272,
        -452
      ],
      "id": "6a9a5139-3395-4f84-a17b-f0655bde2218",
      "name": "HTTP Request",
      "credentials": {
        "erpNextApi": {
          "id": "PCyfMt7tI6h55Qt2",
          "name": "ERPNext account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process parsed resume data and keep skills as array for new table field\nconst items = $input.all();\nconst outputItems = [];\n\nfunction fixDateFormat(dateStr) {\n  if (typeof dateStr !== 'string') return dateStr;\n  const match = dateStr.match(/^(\\d{2})-(\\d{2})-(\\d{4})$/);\n  if (match) {\n    return `${match[3]}-${match[2]}-${match[1]}`;\n  }\n  return dateStr;\n}\n\nfor (const item of items) {\n  let rawText = item.json.text;\n  rawText = rawText.replace(/\\\\n/g, '');\n  let parsed;\n  try {\n    parsed = JSON.parse(rawText);\n  } catch (e) {\n    try {\n      parsed = JSON.parse(rawText.trim());\n    } catch (err) {\n      parsed = { output: {} };\n    }\n  }\n  if (parsed && parsed.output) {\n    // Keep skills as array for new table field in ERPNext doctype\n    // Skills field is now a table, so we keep it as array instead of joining to string\n    console.log('Skills data type:', typeof parsed.output.skills);\n    console.log('Skills is array:', Array.isArray(parsed.output.skills));\n    console.log('Skills content:', parsed.output.skills);\n    \n    // Ensure skills is always an array\n    if (typeof parsed.output.skills === 'string') {\n      // If skills is a string, split it into array\n      parsed.output.skills = parsed.output.skills.split(',').map(skill => skill.trim()).filter(skill => skill.length > 0);\n    } else if (!Array.isArray(parsed.output.skills)) {\n      // If skills is neither string nor array, set empty array\n      parsed.output.skills = [];\n    }\n    \n    console.log('Final skills array:', parsed.output.skills);\n\n    // Fix date fields\n    parsed.output.date_of_birth = fixDateFormat(parsed.output.date_of_birth);\n    parsed.output.passport_issue_date = fixDateFormat(parsed.output.passport_issue_date);\n    parsed.output.passport_expiry_date = fixDateFormat(parsed.output.passport_expiry_date);\n    parsed.output.driving_license_issue_date = fixDateFormat(parsed.output.driving_license_issue_date);\n    parsed.output.driving_license_expiry_date = fixDateFormat(parsed.output.driving_license_expiry_date);\n\n    outputItems.push({ json: parsed.output });\n  } else {\n    outputItems.push({ json: {} });\n  }\n}\n\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2768,
        -164
      ],
      "id": "e0f8a855-4ac9-4e93-85b1-44dabed5cff7",
      "name": "Code1"
    },
    {
      "parameters": {
        "operation": "getAll",
        "docType": "Designation",
        "returnAll": true,
        "options": {
          "fields": [
            "designation_name"
          ]
        }
      },
      "type": "n8n-nodes-base.erpNext",
      "typeVersion": 1,
      "position": [
        -272,
        -768
      ],
      "id": "203b587e-c646-4fc3-8eb3-96f6ac25d934",
      "name": "Get many documents",
      "credentials": {
        "erpNextApi": {
          "id": "PCyfMt7tI6h55Qt2",
          "name": "ERPNext account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2992,
        -768
      ],
      "id": "cde01223-42bc-4a48-9b6d-a69526675c94",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "// Combine applicant data and designation names into a single object and assign all data to a variable\n\nconst input = $input.all().map(item => item.json);\n\n// Find the applicant object (has more than just designation_name)\nconst applicant = input.find(obj => !obj.designation_name);\n\n// Collect all designation names into an array\nconst designations = input\n  .filter(obj => obj.designation_name)\n  .map(obj => obj.designation_name);\n\n// Add the designations array to the applicant object\nlet result;\nif (applicant) {\n  applicant.designation_list = designations;\n  result = applicant;\n} else {\n  result = { designation_list: designations };\n}\n\n// Assign all data to a variable 'text' for LLM\nconst text = JSON.stringify(result);\n\nreturn [{ json: { ...result, text } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3216,
        -768
      ],
      "id": "162507b0-f006-4be3-a753-7c135a1fce2b",
      "name": "Combine Designations and Candidate Data"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are given a list of designations: {{ $json.designation_list }}.\nMatch the candidate's experience, education, skills, and technical qualifications ({{ $json.skills }}, {{ $json.technical_qualification }}, {{ $json.experience }}) to each designation in the list.\n\nFor each designation, assign a score from 0 to 100 based on the candidate's fit, focusing on experience and education.\n\nSTRICT OUTPUT REQUIREMENTS:\n- Output ONLY a valid JSON object.\n- Each key must be a designation from the provided list, and each value must be a score (number or string).\n- Do NOT include any notes, explanations, markdown, or extra text.\n- Do NOT create or invent new designations.\n- Output must start with '{' and end with '}'.\n- Do NOT include any text before or after the JSON.\n\nExample:\n{\n  \"Accountant\": \"80\",\n  \"Engineer\": \"60\",\n  \"Manager\": \"40\"\n}",
        "hasOutputParser": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        3440,
        -768
      ],
      "id": "11caf796-4031-4c0c-a85e-10879384780b",
      "name": "Designation Scorer"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n\t\"designation\":\"score\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        3512,
        -544
      ],
      "id": "161de68b-c525-4e58-a9c0-d30aa339f0cf",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "jsCode": "// Check designation scores and route accordingly\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const scores = item.json.output;\n  let bestDesignation = null;\n  let bestScore = 0;\n  \n  // Find the highest scoring designation\n  for (const [designation, score] of Object.entries(scores)) {\n    const numScore = parseInt(score);\n    if (numScore > bestScore) {\n      bestScore = numScore;\n      bestDesignation = designation;\n    }\n  }\n  \n  // If best score is above 80, use it\n  if (bestScore > 80) {\n    results.push({\n      json: {\n        ...item.json,\n        selected_designation: bestDesignation,\n        designation_score: bestScore,\n        designation_source: 'ai_match',\n        route: 'direct_create'\n      }\n    });\n  } else {\n    // If no score above 80, route to AI to generate a new designation\n    results.push({\n      json: {\n        ...item.json,\n        best_designation: bestDesignation,\n        best_score: bestScore,\n        route: 'ai_assign'\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3792,
        -768
      ],
      "id": "a6c4fe16-77e8-46f2-af09-789c5cd8f548",
      "name": "Designation Logic"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "direct_create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "route-direct"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "ai_assign",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "route-ai"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        4016,
        -768
      ],
      "id": "d20eb78b-4d8e-49bd-bc77-28012f54cf2a",
      "name": "Route Switch"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Based on the candidate's profile and the fact that no existing designation scored above 80%, please create a NEW designation that best fits the candidate's qualifications.\n\nExisting designations (that didn't score above 80%):\n{{ $json.output }}\n\nCandidate Profile:\n- Skills: {{ $json.skills }}\n- Technical Qualification: {{ $json.technical_qualification }}\n- Experience: {{ $json.experience }}\n- Best matching designation so far: {{ $json.best_designation }} ({{ $json.best_score }}%)\n\nSTRICT OUTPUT REQUIREMENTS:\n- Create a NEW, appropriate designation name that is NOT in the existing list above\n- Output ONLY the designation name as a single string\n- The designation should be professional and industry-standard\n- Do NOT include explanations, quotes, or extra text\n- Return just the new designation name\n\nExample output: Senior Data Analyst",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        4464,
        -816
      ],
      "id": "fb58c6ab-3844-46c1-9202-3aa0d9fed535",
      "name": "AI New Designation Creator"
    },
    {
      "parameters": {
        "jsCode": "// Process AI-generated new designation\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const aiDesignation = item.json.text ? item.json.text.trim() : item.json.output;\n  \n  results.push({\n    json: {\n      ...item.json,\n      selected_designation: aiDesignation,\n      designation_score: 85, // Assign high score for AI-generated designation\n      designation_source: 'ai_generated',\n      is_new_designation: true,\n      route: 'create_designation_first' // Need to create this new designation in ERPNext first\n    }\n  });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4816,
        -816
      ],
      "id": "169d73ab-fd00-4a0d-b362-8459f2424c87",
      "name": "Process New AI Designation"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        5040,
        -500
      ],
      "id": "aea417d8-e486-43e2-b736-535ad229c990",
      "name": "Merge3"
    },
    {
      "parameters": {
        "jsCode": "// Merge the two input items: one with personal info, one with designation info\nconst items = $input.all();\nif (items.length < 2) {\n  // Fallback: just return the first item if only one present\n  return items;\n}\n\n// Find the personal info object (has applicant_name) and the designation object (has selected_designation)\nconst personalInfo = items.find(item => item.json.applicant_name);\nconst designationInfo = items.find(item => item.json.selected_designation);\n\n// Merge all fields, with designation fields overwriting if needed\nconst merged = {\n  ...personalInfo.json,\n  ...designationInfo.json\n};\n\n// Ensure designation_list is properly preserved from either source\nif (!merged.designation_list || merged.designation_list.length === 0) {\n  // Try to get designation_list from personal info first, then designation info\n  merged.designation_list = personalInfo?.json?.designation_list || designationInfo?.json?.designation_list || [];\n}\n\n// Debug: Log what we have for designation matching\nconsole.log('DEBUG - Designation matching:', {\n  selected_designation: merged.selected_designation,\n  designation_list: merged.designation_list,\n  designation_list_length: merged.designation_list ? merged.designation_list.length : 0,\n  ai_route_decision: merged.route\n});\n\n// Check if AI has already made a routing decision\nconst aiRouteDecision = merged.route;\nconst hasAIRouting = aiRouteDecision === 'direct_create' || aiRouteDecision === 'create_designation_first';\n\n// Check if the selected designation exists in the designation list\n// Use case-insensitive comparison and trim whitespace for better matching\nconst designationExists = merged.designation_list && merged.designation_list.length > 0 && \n  merged.designation_list.some(designation => \n    designation.toLowerCase().trim() === merged.selected_designation.toLowerCase().trim()\n  );\n\n// Smart routing logic: Respect AI decision when available, fallback to list checking\nlet finalRouteAction;\nlet routingReason;\n\nif (hasAIRouting) {\n  // Trust AI's routing decision\n  if (aiRouteDecision === 'direct_create') {\n    finalRouteAction = 'create_applicant';\n    routingReason = 'ai_determined_designation_exists';\n  } else {\n    finalRouteAction = 'create_designation_first';\n    routingReason = 'ai_determined_designation_missing';\n  }\n} else {\n  // Fallback to traditional list checking\n  finalRouteAction = designationExists ? 'create_applicant' : 'create_designation_first';\n  routingReason = designationExists ? 'list_check_found_match' : 'list_check_no_match';\n}\n\n// Add routing information\nmerged.designation_exists = hasAIRouting ? (aiRouteDecision === 'direct_create') : designationExists;\nmerged.route_action = finalRouteAction;\nmerged.routing_method = hasAIRouting ? 'ai_decision' : 'list_verification';\nmerged.routing_reason = routingReason;\n\n// Add debugging information for troubleshooting\nmerged.debug_info = {\n  selected_designation: merged.selected_designation,\n  selected_normalized: merged.selected_designation ? merged.selected_designation.toLowerCase().trim() : null,\n  designation_list_count: merged.designation_list ? merged.designation_list.length : 0,\n  designation_exists: merged.designation_exists,\n  designation_list_sample: merged.designation_list ? merged.designation_list.slice(0, 5) : [],\n  matching_designations: merged.designation_list ? \n    merged.designation_list.filter(d => \n      d.toLowerCase().trim() === merged.selected_designation.toLowerCase().trim()\n    ) : [],\n  // AI routing information\n  ai_route_decision: aiRouteDecision,\n  has_ai_routing: hasAIRouting,\n  final_route_action: finalRouteAction,\n  routing_method: merged.routing_method,\n  routing_reason: routingReason,\n  // Additional debugging\n  merge_sources: {\n    personal_info_has_designation_list: !!(personalInfo?.json?.designation_list),\n    designation_info_has_designation_list: !!(designationInfo?.json?.designation_list),\n    personal_info_list_count: personalInfo?.json?.designation_list ? personalInfo.json.designation_list.length : 0,\n    designation_info_list_count: designationInfo?.json?.designation_list ? designationInfo.json.designation_list.length : 0\n  }\n};\n\nreturn [{ json: merged }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5264,
        -500
      ],
      "id": "86130c6e-8065-4fe1-9672-b44c1546c45d",
      "name": "Code3"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Analyze this resume/CV document and extract job applicant information into a structured JSON format.\n\nYou are analyzing a visual document (image or PDF page). Carefully examine all text, formatting, and layout elements in the image.\nAnalyze the provided document content image to extract information.\n\n\nYou must return a valid JSON object with a single \"output\" key, containing ALL the following fields:\n{{ $json.fieldnames }}\n\nSTRICT FORMAT REQUIREMENTS:\n- The response MUST be a JSON object with a single \"output\" key\n- The \"output\" object MUST contain ALL {{ $json.total_fields }} fields listed above, no more, no less\n- Known languages should be speaking languages (English, Urdu, Arabic), not programming languages\n- Field-specific formats:\n   - Name : Should not be in all CAPS\n   - Dates: YYYY-MM-DD format only (convert any date format you find)\n   - Phone/mobile: Does not include dashes and space \n   - Email: Must be valid email format\n   - Languages: Must be arrays\n   - IDs (passport, CNIC, etc.): without dashes or spaces\n   - Marital Status: Married/Unmarried ( if it is Single then keep it as Unmarried)\n- Boolean fields (has_passport, has_license): true or false\n\nDefault values for missing information:\n- Names: \"Unknown Applicant\"\n- Email: \"no_email@placeholder.com\"\n- Phone/mobile: 0\n- Dates: \"1900-01-01\"\n- Regular text fields: \"Not Specified\"\n- Arrays: []\n- Known languages: [\"Urdu\"]\n- Skills: \"Not Specified\"\n- Experience: \"Not Specified\"\n- Boolean fields: false\n- Country : Pakistan\n\nEDUCATION EXTRACTION - COMPREHENSIVE APPROACH:\n\n**Education Sources (Check ALL of these):**\n- Dedicated \"Education\" or \"Educational Qualification\" sections\n- \"Academic Background\" or \"Academic Qualifications\" areas\n- \"Qualifications\" or \"Educational History\" sections\n- Individual degree entries with institutions and dates\n- Certifications and professional qualifications\n- Training programs and courses\n- Online courses and certifications\n- Professional development programs\n\n**Education Data to Extract for Each Qualification:**\n1. **Degree/Qualification**: Extract the exact degree name, diploma, or certification\n2. **Institution/University**: Name of the educational institution\n3. **Year of Passing/Completion**: Graduation year or completion date\n4. **Grade/Percentage**: Academic performance if mentioned\n5. **Field of Study**: Major, specialization, or field of study\n\n**Education Level Classification Rules:**\n- **Matric/Secondary**: SSC, Matriculation, Secondary School Certificate, O-Levels, Grade 10, Class 10\n- **Intermediate/Higher Secondary**: FSc, F.Sc, Intermediate, HSSC, A-Levels, ICS, I.C.S, Pre-Medical, Pre-Engineering, Grade 12, Class 12\n- **Diploma**: DAE (Diploma of Associate Engineer), Diploma in any field, Polytechnic Certificate, Technical Diploma, Vocational Training, Trade Certificate, Professional Certificate\n- **Bachelors**: BA, BS, BSc, B.Sc, BE, B.E, BTech, B.Tech, BBA, B.B.A, BCS, B.Com, Bachelor's degree in any field\n- **Masters**: MA, MS, MSc, M.Sc, ME, M.E, MTech, M.Tech, MBA, M.B.A, MCS, M.Com, Master's degree in any field, MPhil, M.Phil, Postgraduate degree\n\n**Specific Education Examples:**\n- \"DAE Electrical\" → Degree: \"Diploma of Associate Engineer in Electrical\", Level: \"Diploma\"\n- \"FSc Pre-Engineering\" → Degree: \"F.Sc Pre-Engineering\", Level: \"FSc\"\n- \"BS Computer Science\" → Degree: \"Bachelor of Science in Computer Science\", Level: \"Bachelors\"\n- \"Matric Science\" → Degree: \"Matriculation in Science\", Level: \"Matric\"\n- \"MBA Finance\" → Degree: \"Master of Business Administration in Finance\", Level: \"Masters\"\n\n**Education Formatting Rules:**\n- Extract EACH qualification as a separate education entry\n- Include institution name even if abbreviated\n- Capture year of passing/completion accurately\n- Include grade/percentage if mentioned\n- Separate multiple qualifications clearly\n- Always extract the full degree name when possible\n- Map abbreviated degrees to full names (e.g., \"DAE\" → \"Diploma of Associate Engineer\")\n\n**Education Extraction Priority:**\n- Look for formal education sections first\n- Check for degrees mentioned in headers or summaries\n- Scan for institution names and years\n- Extract any academic achievements or honors\n- Include professional certifications as education entries\n- Don't miss education mentioned in experience descriptions\n\nEXPERIENCE EXTRACTION - STRUCTURED APPROACH:\n\n**Experience Sources (Check ALL of these):**\n- Dedicated \"Experience\" or \"Work Experience\" sections\n- \"Employment History\" or \"Professional Experience\" areas\n- \"Career Summary\" or \"Work History\" sections\n- Individual job entries with dates and companies\n- Project work mentioned with duration\n- Internships, apprenticeships, and training programs\n- Freelance or contract work\n- Part-time and full-time positions\n\n**Experience Data to Extract for Each Position:**\n1. **Job Title/Position**: Extract the exact job title or role\n2. **Company/Organization**: Name of the employer or institution\n3. **Duration**: Start and end dates, or total years/months\n4. **Key Responsibilities**: Main duties and achievements\n5. **Skills Used**: Technical and soft skills demonstrated\n\n**Experience Formatting Rules:**\n- Extract EACH job/position as a separate experience entry\n- Include duration even if approximate (e.g., \"2 years\", \"6 months\")\n- Capture company names accurately\n- Include both job title and company for each entry\n- Separate multiple positions with clear delimiters\n- Format: \"[Duration] as [Job Title] at [Company] - [Key Responsibilities]\"\n\n**Example Experience Format:**\n\"3 years as Automation Technician at TECNO AUTO GLASS - Installation and troubleshooting of electrical systems; 1 year as Electrical Technician at MULTICON ENGINEERS LTD - PLC programming and HMI configuration; 1 year as Maintenance Engineer at ACCRESCENT ENGINEERING PVT LTD - VFD installation and motor control systems\"\n\nEXTRACTION GUIDELINES:\n- Pay attention to layout and visual organization\n- Scan for any information in margins or headers\n- Look for structured sections and keywords\n- Extract information from any format or layout\n- Extract personal information (name, contact details, address)\n- Find education details from education/qualification sections\n- Identify work experience from employment history\n- Search for passport/CNIC numbers in personal details\n- Pay attention to dates in various formats throughout the document\n- Extract phone numbers and email addresses from contact information\n- Notice any certifications or licenses mentioned\n- Look for languages mentioned in skills or personal sections\n- Be thorough in extracting all available information\n- If you see partial information, extract what you can\n\nSKILLS EXTRACTION - COMPREHENSIVE APPROACH:\n\n**Primary Skills Sources (Check ALL of these):**\n- Dedicated \"Skills\" section\n- \"Technical Skills\" or \"Core Competencies\" sections\n- \"Key Skills\" or \"Professional Skills\" areas\n- \"Software\" or \"Tools\" sections\n- \"Technologies\" or \"Platforms\" sections\n- Skills mentioned within job descriptions/experience\n- Skills listed in project descriptions\n- Certifications that imply skills (e.g., \"Microsoft Office Certified\" = MS Office skills)\n- Education-related skills (programming languages from CS degree, etc.)\n\n**Skills Categories to Extract:**\n\n1. **Technical/Hard Skills:**\n   - Programming languages (Python, Java, C++, JavaScript, etc.)\n   - Software applications (MS Office, AutoCAD, Photoshop, SAP, etc.)\n   - Operating systems (Windows, Linux, macOS, etc.)\n   - Databases (MySQL, Oracle, PostgreSQL, etc.)\n   - Frameworks and libraries (React, Angular, Django, etc.)\n   - Tools and platforms (Git, Docker, AWS, Azure, etc.)\n   - Industry-specific tools (PLC programming, MATLAB, SolidWorks, etc.)\n\n2. **Professional/Soft Skills:**\n   - Communication, Leadership, Project Management\n   - Problem-solving, Analytical thinking\n   - Team collaboration, Customer service\n   - Time management, Organization\n\n3. **Domain-Specific Skills:**\n   - Engineering skills (Electrical design, Circuit analysis, etc.)\n   - Finance skills (Financial analysis, Budgeting, etc.)\n   - Marketing skills (Digital marketing, SEO, etc.)\n   - Medical skills (Patient care, Medical procedures, etc.)\n\n4. **Language Skills:**\n   - Spoken languages (separate from programming languages)\n   - Language proficiency levels if mentioned\n\n**Skills Extraction Rules:**\n- Extract ALL skills mentioned, even if briefly\n- Include skills from experience descriptions (e.g., \"Managed team of 10\" = Leadership, Team Management)\n- Look for skills in bullet points, paragraphs, and lists\n- Extract skills from project descriptions\n- Include skills implied by job titles or responsibilities\n- Separate technical skills from soft skills when possible\n- Include skill variations (e.g., \"MS Word\" and \"Microsoft Word\" as \"Microsoft Word\")\n- Don't miss skills mentioned in context (e.g., \"Experienced in Python programming\")\n\n**Skill Formatting:**\n- Combine into a comprehensive skills string\n- Separate multiple skills with commas\n- Use standard names (e.g., \"Microsoft Excel\" not \"Excel\", \"Python\" not \"python\")\n- Include skill levels if mentioned (e.g., \"Advanced Excel\", \"Intermediate Python\")\n\nIMPORTANT: Your response must be valid JSON that can be parsed. Do not include any explanations, comments, or markdown formatting. Return only the raw JSON object. Your response must start with '{' and end with '}'.",
        "messages": {
          "messageValues": [
            {
              "type": "HumanMessagePromptTemplate",
              "messageType": "imageBinary",
              "binaryImageDataKey": "file"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2416,
        -164
      ],
      "id": "701a9da6-2f2b-4a5b-88a5-ba7ff4304a97",
      "name": "Resume Parser"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.route_action }}",
                    "rightValue": "create_applicant",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "route-direct-applicant"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.route_action }}",
                    "rightValue": "create_designation_first",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "route-create-designation"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        5488,
        -500
      ],
      "id": "8c61268e-49fd-4d37-b624-97d5c932be4e",
      "name": "Designation Check Switch"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        5936,
        -500
      ],
      "id": "38c6ad8d-8fda-482b-b3c4-133326a83224",
      "name": "Final Merge"
    },
    {
      "parameters": {
        "jsCode": "// Process experience data into ERPNext child table format\nconst items = $input.all();\nconst result = [];\n\nfor (const item of items) {\n  const data = item.json;\n  const experienceText = data.experience || \"Not Specified\";\n  \n  // Initialize experience child table array\n  let experienceChildTable = [];\n  \n  // Check if experience is already an array (from our previous processing)\n  if (Array.isArray(data.experience) && data.experience.length > 0) {\n    // Experience is already processed as array, use it directly\n    experienceChildTable = data.experience.map((exp, index) => ({\n      \"doctype\": \"Experience Certifications\",\n      \"company\": exp.company || \"Not Specified\",\n      \"designation\": exp.designation || \"Not Specified\", \n      \"years_of_experience\": exp.years_of_experience || 0,\n      \"experience_description\": exp.experience_description || \"No description\",\n      \"from_date\": exp.from_date || \"1900-01-01\",\n      \"to_date\": exp.to_date || \"1900-01-01\",\n      \"salary\": exp.salary || 0,\n      \"idx\": index + 1,\n      \"parentfield\": \"experience\",\n      \"parenttype\": \"Job Applicant\"\n    }));\n    \n    console.log(`Experience already processed as array with ${experienceChildTable.length} entries`);\n  } else if (typeof experienceText === 'string' && experienceText !== \"Not Specified\" && experienceText.trim() !== \"\") {\n    // Parse experience text into structured format\n    try {\n      // Split by common delimiters and clean up\n      const experienceEntries = experienceText\n        .split(/[;,]|\\band\\b|\\bthen\\b/i)\n        .map(entry => entry.trim())\n        .filter(entry => entry.length > 10); // Filter out very short entries\n      \n      experienceEntries.forEach((entry, index) => {\n        // Extract years/duration pattern\n        const yearPattern = /(\\d+)\\s*(year[s]?|month[s]?|yr[s]?)/i;\n        const yearMatch = entry.match(yearPattern);\n        \n        // Extract company name pattern (variations: \"at Company\", \"in Company\", \"with Company\")\n        const companyPattern = /(?:at|in|with|for)\\s+([A-Z][A-Za-z\\s&\\.,\\-]+?)(?:\\s*[-–—]|$|\\s+as\\s|\\s+doing\\s)/i;\n        const companyMatch = entry.match(companyPattern);\n        \n        // Extract job title pattern (variations: \"as Title\", \"working as Title\")\n        const titlePattern = /(?:as|working as)\\s+([A-Za-z\\s&\\.,\\-]+?)(?:\\s*at|\\s*in|\\s*with|\\s*for|\\s*[-–—]|$)/i;\n        const titleMatch = entry.match(titlePattern);\n        \n        // Alternative patterns for different formats\n        let duration = \"Not Specified\";\n        let company = \"Not Specified\";\n        let title = \"Not Specified\";\n        \n        // Extract duration\n        if (yearMatch) {\n          duration = `${yearMatch[1]} ${yearMatch[2].toLowerCase()}`;\n        }\n        \n        // Extract company\n        if (companyMatch) {\n          company = companyMatch[1].trim().replace(/[,;]$/, ''); // Remove trailing punctuation\n        }\n        \n        // Extract job title\n        if (titleMatch) {\n          title = titleMatch[1].trim().replace(/[,;]$/, ''); // Remove trailing punctuation\n        } else {\n          // Try to extract title from the beginning of the entry\n          const words = entry.split(/\\s+/);\n          const commonTitles = ['technician', 'engineer', 'manager', 'developer', 'analyst', 'assistant', 'officer', 'supervisor', 'coordinator', 'specialist'];\n          for (let i = 0; i < Math.min(5, words.length); i++) {\n            if (commonTitles.some(titleWord => words[i].toLowerCase().includes(titleWord))) {\n              title = words.slice(0, i + 1).join(' ');\n              break;\n            }\n          }\n        }\n        \n        // If we couldn't extract company or title, use fallback approach\n        if (company === \"Not Specified\" || title === \"Not Specified\") {\n          // Look for ALL CAPS words (often company names)\n          const allCapsPattern = /\\b[A-Z]{2,}(?:\\s+[A-Z]{2,})*\\b/g;\n          const allCapsMatches = entry.match(allCapsPattern);\n          \n          if (allCapsMatches && company === \"Not Specified\") {\n            company = allCapsMatches[0];\n          }\n          \n          // If still no title, use a generic extraction\n          if (title === \"Not Specified\") {\n            const firstWords = entry.split(/\\s+/).slice(0, 3).join(' ');\n            if (firstWords.length > 5) {\n              title = firstWords;\n            }\n          }\n        }\n        \n        // Create experience entry in ERPNext child table format\n        const experienceEntry = {\n          \"doctype\": \"Experience Certifications\",  // Child table doctype\n          \"company\": company,\n          \"designation\": title,\n          \"years_of_experience\": duration,\n          \"experience_description\": entry.slice(0, 200), // Limit description length\n          \"idx\": index + 1,  // Row index for child table\n          \"parentfield\": \"experience\",  // Parent field name\n          \"parenttype\": \"Job Applicant\"  // Parent doctype\n        };\n        \n        experienceChildTable.push(experienceEntry);\n      });\n      \n      // If no structured entries were created, create a single entry with all text\n      if (experienceChildTable.length === 0) {\n        experienceChildTable.push({\n          \"doctype\": \"Experience Certifications\",\n          \"company\": \"Various Companies\",\n          \"designation\": data.job_title || \"Not Specified\",\n          \"years_of_experience\": \"Not Specified\",\n          \"experience_description\": experienceText.slice(0, 200),\n          \"idx\": 1,\n          \"parentfield\": \"experience\",\n          \"parenttype\": \"Job Applicant\"\n        });\n      }\n    } catch (error) {\n      console.log('Error parsing experience:', error);\n      // Fallback to simple entry\n      experienceChildTable.push({\n        \"doctype\": \"Experience Certifications\",\n        \"company\": \"Not Specified\",\n        \"designation\": data.job_title || \"Not Specified\",\n        \"years_of_experience\": \"Not Specified\",\n        \"experience_description\": experienceText.slice(0, 200),\n        \"idx\": 1,\n        \"parentfield\": \"experience\",\n        \"parenttype\": \"Job Applicant\"\n      });\n    }\n  } else {\n    // No experience data or empty experience\n    console.log('No experience data found or data is empty');\n    experienceChildTable = [];\n  }\n  \n  // Add the structured experience data to the result\n  result.push({\n    json: {\n      ...data,\n      experience: experienceChildTable,  // ERPNext expects 'experience' field name\n      experience_count: experienceChildTable.length,\n      experience_processing_debug: {\n        original_experience: experienceText,\n        parsed_entries: experienceChildTable.length,\n        processing_method: \"child_table_format\"\n      }\n    }\n  });\n}\n\nreturn result;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6160,
        -500
      ],
      "id": "0816f795-fea0-41ba-902c-ec5a62514de4",
      "name": "Process Experience Data"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        2488,
        60
      ],
      "id": "abfa2f5e-25c9-4af0-922a-c5fc2bcd2f75",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "553djEfLQRobcIUg",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        4536,
        -592
      ],
      "id": "329b5403-c9f0-46ed-8b31-45014a100060",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "553djEfLQRobcIUg",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1072,
        -260
      ],
      "id": "3b4eb1e0-7d7e-4342-91c1-2da139158e4a",
      "name": "Merge2"
    },
    {
      "parameters": {
        "jsCode": "// Generated by Copilot\n// filepath: i:\\D Drive\\N8N_Resume_Parsing\\n8n\\workflow.json\n// Update the \"Combine Data1\" node with this improved logic:\n\n// Combine file data and fieldnames properly, ensure binary data is preserved\nconst items = $input.all();\n\nif (items.length < 2) {\n  // If we don't have both inputs, just pass through what we have\n  return items;\n}\n\nconst fileData = items[0];       // From Switch1 -> Merge2 (has binary data)\nconst fieldnamesData = items[1]; // From HTTP Request -> Get Field Names (has fieldnames)\n\n// Properly combine into a single item with both JSON data and binary data\nconst result = {\n  json: {\n    // Merge all JSON data from both sources\n    ...fileData.json,\n    ...fieldnamesData.json,\n    // Add debug info\n    data_sources: {\n      file_data_keys: Object.keys(fileData.json || {}),\n      fieldnames_data_keys: Object.keys(fieldnamesData.json || {}),\n      has_binary_data: !!fileData.binary,\n      binary_keys: fileData.binary ? Object.keys(fileData.binary) : []\n    }\n  },\n  // Preserve binary data from file input\n  binary: fileData.binary || {}\n};\n\n// Return single combined item\nreturn [result];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1296,
        -260
      ],
      "id": "a64f8eb2-321c-44b1-880a-df36c57e5518",
      "name": "Combine Data1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://imp-fastapi:8000/api/documents/extract-images",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "file"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "extracted_image"
            }
          }
        }
      },
      "id": "4000edbe-8cd3-4e05-a181-17c6b7c074df",
      "name": "Extract Images from PDF",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1520,
        -260
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for Resume Parser with extracted image\nconst items = $input.all();\nconst result = [];\n\nfor (const item of items) {\n  // Use extracted image if available, otherwise use original file\n  const binaryData = item.binary.extracted_image || item.binary.file;\n  \n  result.push({\n    json: {\n      ...item.json,\n      image_extracted: !!item.binary.extracted_image,\n      processing_method: item.binary.extracted_image ? 'vision_analysis' : 'direct_file'\n    },\n    binary: {\n      file: binaryData\n    }\n  });\n}\n\nreturn result;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1744,
        -260
      ],
      "id": "8f27186a-5a03-4252-92bc-4c4af1975f22",
      "name": "Prepare for Vision Analysis"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.image_extracted }}",
                    "rightValue": true,
                    "operator": {
                      "type": "boolean",
                      "operation": "true"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1968,
        -260
      ],
      "id": "45565427-f654-41d3-a599-791d25e0a3d4",
      "name": "Image Extraction Check"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://imp-fastapi:8000/api/documents/extract-text",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "file"
            }
          ]
        },
        "options": {}
      },
      "id": "98607f55-7b0f-4103-af8f-b2d671fc2b19",
      "name": "Extract Text Fallback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1744,
        -68
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare text data for Resume Parser when image extraction fails\nconst items = $input.all();\nconst result = [];\n\nfor (const item of items) {\n  result.push({\n    json: {\n      ...item.json,\n      processing_method: 'text_analysis',\n      extracted_text: item.json.text_content || 'No text extracted',\n      fallback_reason: 'Image extraction failed or unavailable'\n    },\n    binary: item.binary || {}\n  });\n}\n\nreturn result;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        -68
      ],
      "id": "a81fe13b-276b-45bf-9435-2bf2d8767b67",
      "name": "Prepare Text Analysis"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2192,
        -164
      ],
      "id": "dd4e6374-762c-409b-b403-32fd830148d7",
      "name": "Merge Processing Routes"
    },
    {
      "parameters": {
        "path": "df313a6d-b069-4028-b4cb-d49ae75b69e9",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -752,
        -304
      ],
      "id": "ea91c032-782a-444c-bc48-951461195210",
      "name": "Webhook",
      "webhookId": "df313a6d-b069-4028-b4cb-d49ae75b69e9"
    },
    {
      "parameters": {
        "formTitle": "upload",
        "formFields": {
          "values": [
            {
              "fieldLabel": "file",
              "fieldType": "file"
            }
          ]
        },
        "responseMode": "lastNode",
        "options": {
          "buttonLabel": "Submit"
        }
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [
        -752,
        -496
      ],
      "id": "86ac5e8f-e7f4-4912-a963-905bfc238050",
      "name": "On form submission",
      "webhookId": "e5dee929-3e06-407f-aac1-3a32bf6a505e"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        4240,
        -816
      ],
      "id": "a6e31a37-112d-4743-93d4-65401b9fa03c",
      "name": "Merge4"
    },
    {
      "parameters": {
        "content": "## DOCX to PDF",
        "height": 224,
        "width": 400
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        696,
        -156
      ],
      "typeVersion": 1,
      "id": "fcb47baf-da18-4f30-8f4f-30d1111fe395",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "docType": "Designation",
        "properties": {
          "customProperty": [
            {
              "field": "designation_name",
              "value": "={{ $json.selected_designation }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.erpNext",
      "typeVersion": 1,
      "position": [
        5712,
        -428
      ],
      "id": "53719a23-3cd8-4e80-961a-7f68d1d900cd",
      "name": "Create Designation",
      "credentials": {
        "erpNextApi": {
          "id": "PCyfMt7tI6h55Qt2",
          "name": "ERPNext account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "docType": "Job%20Applicant",
        "properties": {
          "customProperty": [
            {
              "field": "applicant_name",
              "value": "={{ $json.applicant_name }}"
            },
            {
              "field": "email_id",
              "value": "={{ $json.email_id }}"
            },
            {
              "field": "phone_number",
              "value": "={{ $json.phone_number }}"
            },
            {
              "field": "country",
              "value": "={{ $json.country }}"
            },
            {
              "field": "date_of_birth",
              "value": "={{ $json.date_of_birth }}"
            },
            {
              "field": "cnic_number",
              "value": "={{ $json.cnic_number }}"
            },
            {
              "field": "gender",
              "value": "={{ $json.gender }}"
            },
            {
              "field": "skills",
              "value": "={{ $json.skills.map((skill, index) => ({ skill: skill.trim(), idx: index + 1 })) }}"
            },
            {
              "field": "father_name",
              "value": "={{ $json.father_name }}"
            },
            {
              "field": "mother_name",
              "value": "={{ $json.mother_name }}"
            },
            {
              "field": "street_address",
              "value": "={{ $json.street_address }}"
            },
            {
              "field": "city",
              "value": "={{ $json.city }}"
            },
            {
              "field": "province",
              "value": "={{ $json.province }}"
            },
            {
              "field": "marital_status",
              "value": "={{ $json.marital_status }}"
            },
            {
              "field": "religion",
              "value": "={{ $json.religion }}"
            },
            {
              "field": "sect",
              "value": "={{ $json.sect }}"
            },
            {
              "field": "telephone_number",
              "value": "={{ $json.telephone_number }}"
            },
            {
              "field": "known_languages",
              "value": "={{ $json.known_languages[0] }}"
            },
            {
              "field": "nationality",
              "value": "={{ $json.nationality }}"
            },
            {
              "field": "designation",
              "value": "={{ $json.selected_designation }}"
            },
            {
              "field": "experience",
              "value": "={{ $json.experience_certifications }}"
            },
            {
              "field": "qualification_block",
              "value": "={{ $json.educational_qualification }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.erpNext",
      "typeVersion": 1,
      "position": [
        7056,
        -496
      ],
      "id": "077e15e1-4597-4b95-80b6-66d42f277003",
      "name": "Create Job Applicant",
      "credentials": {
        "erpNextApi": {
          "id": "PCyfMt7tI6h55Qt2",
          "name": "ERPNext account"
        }
      }
    }
  ],
  "connections": {
    "Edit Fields1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Classification Engine1": {
      "main": [
        [
          {
            "node": "Classify File Type1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Classify File Type1": {
      "main": [
        [
          {
            "node": "Edit Fields1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "Convert DOCX to PDF (FastAPI)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Convert DOCX to PDF (FastAPI)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert DOCX to PDF (FastAPI)": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Experience and Education Data": {
      "main": [
        [
          {
            "node": "Collect Experience and Education Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Experience and Education Data": {
      "main": [
        [
          {
            "node": "Merge Job Applicant Experience and Education",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Job Applicant Experience and Education": {
      "main": [
        [
          {
            "node": "Create Job Applicant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Field Names": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Get Field Names",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code1": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge4",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get many documents": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Combine Designations and Candidate Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Designations and Candidate Data": {
      "main": [
        [
          {
            "node": "Designation Scorer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Designation Scorer": {
      "main": [
        [
          {
            "node": "Designation Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Designation Scorer",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Designation Logic": {
      "main": [
        [
          {
            "node": "Route Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Switch": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI New Designation Creator": {
      "main": [
        [
          {
            "node": "Process New AI Designation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process New AI Designation": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "Code3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code3": {
      "main": [
        [
          {
            "node": "Designation Check Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resume Parser": {
      "main": [
        [
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Designation Check Switch": {
      "main": [
        [
          {
            "node": "Final Merge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Designation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Final Merge": {
      "main": [
        [
          {
            "node": "Process Experience Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Experience Data": {
      "main": [
        [
          {
            "node": "Merge Job Applicant Experience and Education",
            "type": "main",
            "index": 0
          },
          {
            "node": "Split Experience and Education Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Resume Parser",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Designation Scorer",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "AI New Designation Creator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Combine Data1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Data1": {
      "main": [
        [
          {
            "node": "Extract Images from PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Images from PDF": {
      "main": [
        [
          {
            "node": "Prepare for Vision Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Vision Analysis": {
      "main": [
        [
          {
            "node": "Image Extraction Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Image Extraction Check": {
      "main": [
        [
          {
            "node": "Merge Processing Routes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text Fallback": {
      "main": [
        [
          {
            "node": "Prepare Text Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Text Analysis": {
      "main": [
        [
          {
            "node": "Merge Processing Routes",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Processing Routes": {
      "main": [
        [
          {
            "node": "Resume Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Classification Engine1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get many documents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "On form submission": {
      "main": [
        [
          {
            "node": "Get many documents",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          },
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          },
          {
            "node": "Classification Engine1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge4": {
      "main": [
        [
          {
            "node": "AI New Designation Creator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Designation": {
      "main": [
        [
          {
            "node": "Final Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "8dbc788362a7064be1e99adf037458c451d1265e79b52ecf653899e06c56f8d2"
  }
}